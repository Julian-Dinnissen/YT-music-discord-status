{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;AAAa;;AAEb,qBAAqB,mBAAO,CAAC,4DAAQ;AACrC,QAAQ,2BAA2B,EAAE,mBAAO,CAAC,2DAAQ;AACrD,cAAc,mBAAO,CAAC,qEAAY;AAClC,mBAAmB,mBAAO,CAAC,qFAAc;AACzC,QAAQ,4CAA4C,EAAE,mBAAO,CAAC,6EAAa;AAC3E,QAAQ,oBAAoB,EAAE,mBAAO,CAAC,mEAAQ;;AAE9C;AACA,YAAY,MAAM,EAAE,qBAAqB;AACzC;;AAEA;AACA,aAAa;AACb,aAAa;AACb,UAAU,QAAQ;AAClB;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA,0BAA0B;AAC1B;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kCAAkC,cAAc,IAAI;AACpD,eAAe,oBAAoB,EAAE,KAAK,EAAE,wCAAwC;AACpF;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;;AAEA;AACA,eAAe;AACf,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA,6BAA6B,gDAAgD;AAC7E,eAAe;AACf;AACA,0BAA0B;AAC1B,UAAU,wBAAwB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ,QAAQ;AAC7B,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD,mCAAmC,iBAAiB;AACpD,KAAK;AACL;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA,oBAAoB,sDAAsD,IAAI;AAC9E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA,0CAA0C,2BAA2B;AACrE,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;AAGA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA,iDAAiD,uBAAuB;AACxE;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA,kDAAkD,SAAS;AAC3D;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA,mDAAmD,yBAAyB;AAC5E;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,eAAe;AACf,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,UAAU;AACtB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB;;AAEA;AACA;AACA,aAAa,mBAAmB;AAChC,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA,eAAe;AACf,YAAY,WAAW;AACvB,YAAY,SAAS;AACrB;AACA,YAAY,SAAS;AACrB,YAAY,MAAM;AAClB;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,mBAAmB;AAChC,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,eAAe;AACf;AACA,2BAA2B,yBAAyB,IAAI;AACxD,4DAA4D,gCAAgC;AAC5F;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA,eAAe;AACf;AACA,0BAA0B,UAAU,IAAI;AACxC,2DAA2D,yBAAyB;AACpF;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,0DAA0D,gBAAgB;AAC1E;AACA,sCAAsC,UAAU;AAChD;AACA,KAAK;AACL,wDAAwD,iBAAiB;AACzE;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe;AACf;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,MAAM;AACnB,eAAe;AACf;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,MAAM;AACnB,eAAe;AACf;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,aAAa,MAAM;AACnB,eAAe;AACf;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,uBAAuB,kCAAkC,IAAI;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ,8BAA8B,oBAAoB;AACvE,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACnpBa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,eAAe;;AAEf,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjLa;;AAEb,aAAa,mBAAO,CAAC,mEAAQ;;AAE7B;AACA,UAAU,mBAAO,CAAC,uEAAU;AAC5B;AACA,oCAAoC,GAAG;AACvC,GAAG;AACH;;;;;;;;;;;;ACTa;;AAEb;AACA,OAAO,mBAAO,CAAC,4EAAO;AACtB,aAAa,mBAAO,CAAC,wFAAa;AAClC;;;;;;;;;;;;ACLa;;AAEb,YAAY,mBAAO,CAAC,kBAAK;AACzB,qBAAqB,mBAAO,CAAC,4DAAQ;AACrC,cAAc,mBAAO,CAAC,qEAAY;AAClC,QAAQ,OAAO,EAAE,mBAAO,CAAC,oEAAS;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,GAAG;AAC1C;AACA,UAAU,OAAO,uCAAuC;AACxD;AACA,YAAY,0BAA0B,eAAe,GAAG;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,oBAAoB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,KAAK;AACb;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,eAAe,UAAU,GAAG;AAC5B;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB,qBAAqB;;;;;;;;;;;;AC5KR;;AAEb,qBAAqB,mBAAO,CAAC,4DAAQ;AACrC,QAAQ,UAAU,EAAE,mBAAO,CAAC,8EAAc;;AAE1C;AACA,+CAA+C,mBAAO,CAAC,iBAAI;;AAE3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,KAAK,kBAAkB,qBAAqB;AACpE,8BAA8B,oCAAoC;AAClE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,SAAS;;AAEf;AACA;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;AC5Ea;;AAEb;AACA;AACA,UAAU,MAAM,EAAE,mBAAO,CAAC,uBAAU;AACpC;AACA,EAAE;AACF;AACA,eAAe,mBAAO,CAAC,8BAAiB;AACxC,IAAI,aAAa;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,sBAAsB;AACxC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA,SAAS,yBAAyB;AAClC;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAA8D,YAAY;AAC1E;AACA,8DAA8D,YAAY;AAC1E;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;;;;;;;;;;;;AChfa;;AAEb;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,sCAAsC;AACtC,YAAY,qBAAM,oBAAoB,OAAO,qBAAM;AACnD;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,CAAC,kBAAe;AAChB;;AAEA,eAAe;AACf,eAAe;AACf,gBAAgB;;;;;;;;;;;;ACvBhB,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC/EA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;ACNqC;AACrC;AACA;AACA;AACA,gBAAgB,2DAAiB,GAAG,kBAAkB;AACtD;AACA,2DAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oDAAoD;AAC5D,QAAQ,4DAA4D;AACpE;AACA,GAAG;AACH,CAAC;AACD;AACA,YAAY,oBAAoB,uB","sources":["webpack:///../../../../../node_modules/discord-rpc/src/client.js","webpack:///../../../../../node_modules/discord-rpc/src/constants.js","webpack:///../../../../../node_modules/discord-rpc/src/index.js","webpack:///../../../../../node_modules/discord-rpc/src/transports/index.js","webpack:///../../../../../node_modules/discord-rpc/src/transports/ipc.js","webpack:///../../../../../node_modules/discord-rpc/src/transports/websocket.js","webpack:///../../../../../node_modules/discord-rpc/src/util.js","webpack:///../../../../../node_modules/events/events.js","webpack:///../../../../../node_modules/node-fetch/browser.js","webpack:///../../../../../node_modules/timers/index.js","webpack:///ignored|C:\\Users\\Julian\\node_modules\\discord-rpc\\src\\transports|net","webpack:///ignored|C:\\Users\\Julian\\node_modules\\discord-rpc\\src\\transports|ws","webpack:///ignored|C:\\Users\\Julian\\node_modules\\discord-rpc\\src|electron","webpack:///ignored|C:\\Users\\Julian\\node_modules\\discord-rpc\\src|register-scheme","webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/global","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./index.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst { setTimeout, clearTimeout } = require('timers');\nconst fetch = require('node-fetch');\nconst transports = require('./transports');\nconst { RPCCommands, RPCEvents, RelationshipTypes } = require('./constants');\nconst { pid: getPid, uuid } = require('./util');\n\nfunction subKey(event, args) {\n  return `${event}${JSON.stringify(args)}`;\n}\n\n/**\n * @typedef {RPCClientOptions}\n * @extends {ClientOptions}\n * @prop {string} transport RPC transport. one of `ipc` or `websocket`\n */\n\n/**\n * The main hub for interacting with Discord RPC\n * @extends {BaseClient}\n */\nclass RPCClient extends EventEmitter {\n  /**\n   * @param {RPCClientOptions} [options] Options for the client.\n   * You must provide a transport\n   */\n  constructor(options = {}) {\n    super();\n\n    this.options = options;\n\n    this.accessToken = null;\n    this.clientId = null;\n\n    /**\n     * Application used in this client\n     * @type {?ClientApplication}\n     */\n    this.application = null;\n\n    /**\n     * User used in this application\n     * @type {?User}\n     */\n    this.user = null;\n\n    const Transport = transports[options.transport];\n    if (!Transport) {\n      throw new TypeError('RPC_INVALID_TRANSPORT', options.transport);\n    }\n\n    this.fetch = (method, path, { data, query } = {}) =>\n      fetch(`${this.fetch.endpoint}${path}${query ? new URLSearchParams(query) : ''}`, {\n        method,\n        body: data,\n        headers: {\n          Authorization: `Bearer ${this.accessToken}`,\n        },\n      }).then(async (r) => {\n        const body = await r.json();\n        if (!r.ok) {\n          const e = new Error(r.status);\n          e.body = body;\n          throw e;\n        }\n        return body;\n      });\n\n    this.fetch.endpoint = 'https://discord.com/api';\n\n    /**\n     * Raw transport userd\n     * @type {RPCTransport}\n     * @private\n     */\n    this.transport = new Transport(this);\n    this.transport.on('message', this._onRpcMessage.bind(this));\n\n    /**\n     * Map of nonces being expected from the transport\n     * @type {Map}\n     * @private\n     */\n    this._expecting = new Map();\n\n    this._connectPromise = undefined;\n  }\n\n  /**\n   * Search and connect to RPC\n   */\n  connect(clientId) {\n    if (this._connectPromise) {\n      return this._connectPromise;\n    }\n    this._connectPromise = new Promise((resolve, reject) => {\n      this.clientId = clientId;\n      const timeout = setTimeout(() => reject(new Error('RPC_CONNECTION_TIMEOUT')), 10e3);\n      timeout.unref();\n      this.once('connected', () => {\n        clearTimeout(timeout);\n        resolve(this);\n      });\n      this.transport.once('close', () => {\n        this._expecting.forEach((e) => {\n          e.reject(new Error('connection closed'));\n        });\n        this.emit('disconnected');\n        reject(new Error('connection closed'));\n      });\n      this.transport.connect().catch(reject);\n    });\n    return this._connectPromise;\n  }\n\n  /**\n   * @typedef {RPCLoginOptions}\n   * @param {string} clientId Client ID\n   * @param {string} [clientSecret] Client secret\n   * @param {string} [accessToken] Access token\n   * @param {string} [rpcToken] RPC token\n   * @param {string} [tokenEndpoint] Token endpoint\n   * @param {string[]} [scopes] Scopes to authorize with\n   */\n\n  /**\n   * Performs authentication flow. Automatically calls Client#connect if needed.\n   * @param {RPCLoginOptions} options Options for authentication.\n   * At least one property must be provided to perform login.\n   * @example client.login({ clientId: '1234567', clientSecret: 'abcdef123' });\n   * @returns {Promise<RPCClient>}\n   */\n  async login(options = {}) {\n    let { clientId, accessToken } = options;\n    await this.connect(clientId);\n    if (!options.scopes) {\n      this.emit('ready');\n      return this;\n    }\n    if (!accessToken) {\n      accessToken = await this.authorize(options);\n    }\n    return this.authenticate(accessToken);\n  }\n\n  /**\n   * Request\n   * @param {string} cmd Command\n   * @param {Object} [args={}] Arguments\n   * @param {string} [evt] Event\n   * @returns {Promise}\n   * @private\n   */\n  request(cmd, args, evt) {\n    return new Promise((resolve, reject) => {\n      const nonce = uuid();\n      this.transport.send({ cmd, args, evt, nonce });\n      this._expecting.set(nonce, { resolve, reject });\n    });\n  }\n\n  /**\n   * Message handler\n   * @param {Object} message message\n   * @private\n   */\n  _onRpcMessage(message) {\n    if (message.cmd === RPCCommands.DISPATCH && message.evt === RPCEvents.READY) {\n      if (message.data.user) {\n        this.user = message.data.user;\n      }\n      this.emit('connected');\n    } else if (this._expecting.has(message.nonce)) {\n      const { resolve, reject } = this._expecting.get(message.nonce);\n      if (message.evt === 'ERROR') {\n        const e = new Error(message.data.message);\n        e.code = message.data.code;\n        e.data = message.data;\n        reject(e);\n      } else {\n        resolve(message.data);\n      }\n      this._expecting.delete(message.nonce);\n    } else {\n      this.emit(message.evt, message.data);\n    }\n  }\n\n  /**\n   * Authorize\n   * @param {Object} options options\n   * @returns {Promise}\n   * @private\n   */\n  async authorize({ scopes, clientSecret, rpcToken, redirectUri, prompt } = {}) {\n    if (clientSecret && rpcToken === true) {\n      const body = await this.fetch('POST', '/oauth2/token/rpc', {\n        data: new URLSearchParams({\n          client_id: this.clientId,\n          client_secret: clientSecret,\n        }),\n      });\n      rpcToken = body.rpc_token;\n    }\n\n    const { code } = await this.request('AUTHORIZE', {\n      scopes,\n      client_id: this.clientId,\n      prompt,\n      rpc_token: rpcToken,\n    });\n\n    const response = await this.fetch('POST', '/oauth2/token', {\n      data: new URLSearchParams({\n        client_id: this.clientId,\n        client_secret: clientSecret,\n        code,\n        grant_type: 'authorization_code',\n        redirect_uri: redirectUri,\n      }),\n    });\n\n    return response.access_token;\n  }\n\n  /**\n   * Authenticate\n   * @param {string} accessToken access token\n   * @returns {Promise}\n   * @private\n   */\n  authenticate(accessToken) {\n    return this.request('AUTHENTICATE', { access_token: accessToken })\n      .then(({ application, user }) => {\n        this.accessToken = accessToken;\n        this.application = application;\n        this.user = user;\n        this.emit('ready');\n        return this;\n      });\n  }\n\n\n  /**\n   * Fetch a guild\n   * @param {Snowflake} id Guild ID\n   * @param {number} [timeout] Timeout request\n   * @returns {Promise<Guild>}\n   */\n  getGuild(id, timeout) {\n    return this.request(RPCCommands.GET_GUILD, { guild_id: id, timeout });\n  }\n\n  /**\n   * Fetch all guilds\n   * @param {number} [timeout] Timeout request\n   * @returns {Promise<Collection<Snowflake, Guild>>}\n   */\n  getGuilds(timeout) {\n    return this.request(RPCCommands.GET_GUILDS, { timeout });\n  }\n\n  /**\n   * Get a channel\n   * @param {Snowflake} id Channel ID\n   * @param {number} [timeout] Timeout request\n   * @returns {Promise<Channel>}\n   */\n  getChannel(id, timeout) {\n    return this.request(RPCCommands.GET_CHANNEL, { channel_id: id, timeout });\n  }\n\n  /**\n   * Get all channels\n   * @param {Snowflake} [id] Guild ID\n   * @param {number} [timeout] Timeout request\n   * @returns {Promise<Collection<Snowflake, Channel>>}\n   */\n  async getChannels(id, timeout) {\n    const { channels } = await this.request(RPCCommands.GET_CHANNELS, {\n      timeout,\n      guild_id: id,\n    });\n    return channels;\n  }\n\n  /**\n   * @typedef {CertifiedDevice}\n   * @prop {string} type One of `AUDIO_INPUT`, `AUDIO_OUTPUT`, `VIDEO_INPUT`\n   * @prop {string} uuid This device's Windows UUID\n   * @prop {object} vendor Vendor information\n   * @prop {string} vendor.name Vendor's name\n   * @prop {string} vendor.url Vendor's url\n   * @prop {object} model Model information\n   * @prop {string} model.name Model's name\n   * @prop {string} model.url Model's url\n   * @prop {string[]} related Array of related product's Windows UUIDs\n   * @prop {boolean} echoCancellation If the device has echo cancellation\n   * @prop {boolean} noiseSuppression If the device has noise suppression\n   * @prop {boolean} automaticGainControl If the device has automatic gain control\n   * @prop {boolean} hardwareMute If the device has a hardware mute\n   */\n\n  /**\n   * Tell discord which devices are certified\n   * @param {CertifiedDevice[]} devices Certified devices to send to discord\n   * @returns {Promise}\n   */\n  setCertifiedDevices(devices) {\n    return this.request(RPCCommands.SET_CERTIFIED_DEVICES, {\n      devices: devices.map((d) => ({\n        type: d.type,\n        id: d.uuid,\n        vendor: d.vendor,\n        model: d.model,\n        related: d.related,\n        echo_cancellation: d.echoCancellation,\n        noise_suppression: d.noiseSuppression,\n        automatic_gain_control: d.automaticGainControl,\n        hardware_mute: d.hardwareMute,\n      })),\n    });\n  }\n\n  /**\n   * @typedef {UserVoiceSettings}\n   * @prop {Snowflake} id ID of the user these settings apply to\n   * @prop {?Object} [pan] Pan settings, an object with `left` and `right` set between\n   * 0.0 and 1.0, inclusive\n   * @prop {?number} [volume=100] The volume\n   * @prop {bool} [mute] If the user is muted\n   */\n\n  /**\n   * Set the voice settings for a user, by id\n   * @param {Snowflake} id ID of the user to set\n   * @param {UserVoiceSettings} settings Settings\n   * @returns {Promise}\n   */\n  setUserVoiceSettings(id, settings) {\n    return this.request(RPCCommands.SET_USER_VOICE_SETTINGS, {\n      user_id: id,\n      pan: settings.pan,\n      mute: settings.mute,\n      volume: settings.volume,\n    });\n  }\n\n  /**\n   * Move the user to a voice channel\n   * @param {Snowflake} id ID of the voice channel\n   * @param {Object} [options] Options\n   * @param {number} [options.timeout] Timeout for the command\n   * @param {boolean} [options.force] Force this move. This should only be done if you\n   * have explicit permission from the user.\n   * @returns {Promise}\n   */\n  selectVoiceChannel(id, { timeout, force = false } = {}) {\n    return this.request(RPCCommands.SELECT_VOICE_CHANNEL, { channel_id: id, timeout, force });\n  }\n\n  /**\n   * Move the user to a text channel\n   * @param {Snowflake} id ID of the voice channel\n   * @param {Object} [options] Options\n   * @param {number} [options.timeout] Timeout for the command\n   * have explicit permission from the user.\n   * @returns {Promise}\n   */\n  selectTextChannel(id, { timeout } = {}) {\n    return this.request(RPCCommands.SELECT_TEXT_CHANNEL, { channel_id: id, timeout });\n  }\n\n  /**\n   * Get current voice settings\n   * @returns {Promise}\n   */\n  getVoiceSettings() {\n    return this.request(RPCCommands.GET_VOICE_SETTINGS)\n      .then((s) => ({\n        automaticGainControl: s.automatic_gain_control,\n        echoCancellation: s.echo_cancellation,\n        noiseSuppression: s.noise_suppression,\n        qos: s.qos,\n        silenceWarning: s.silence_warning,\n        deaf: s.deaf,\n        mute: s.mute,\n        input: {\n          availableDevices: s.input.available_devices,\n          device: s.input.device_id,\n          volume: s.input.volume,\n        },\n        output: {\n          availableDevices: s.output.available_devices,\n          device: s.output.device_id,\n          volume: s.output.volume,\n        },\n        mode: {\n          type: s.mode.type,\n          autoThreshold: s.mode.auto_threshold,\n          threshold: s.mode.threshold,\n          shortcut: s.mode.shortcut,\n          delay: s.mode.delay,\n        },\n      }));\n  }\n\n  /**\n   * Set current voice settings, overriding the current settings until this session disconnects.\n   * This also locks the settings for any other rpc sessions which may be connected.\n   * @param {Object} args Settings\n   * @returns {Promise}\n   */\n  setVoiceSettings(args) {\n    return this.request(RPCCommands.SET_VOICE_SETTINGS, {\n      automatic_gain_control: args.automaticGainControl,\n      echo_cancellation: args.echoCancellation,\n      noise_suppression: args.noiseSuppression,\n      qos: args.qos,\n      silence_warning: args.silenceWarning,\n      deaf: args.deaf,\n      mute: args.mute,\n      input: args.input ? {\n        device_id: args.input.device,\n        volume: args.input.volume,\n      } : undefined,\n      output: args.output ? {\n        device_id: args.output.device,\n        volume: args.output.volume,\n      } : undefined,\n      mode: args.mode ? {\n        type: args.mode.type,\n        auto_threshold: args.mode.autoThreshold,\n        threshold: args.mode.threshold,\n        shortcut: args.mode.shortcut,\n        delay: args.mode.delay,\n      } : undefined,\n    });\n  }\n\n  /**\n   * Capture a shortcut using the client\n   * The callback takes (key, stop) where `stop` is a function that will stop capturing.\n   * This `stop` function must be called before disconnecting or else the user will have\n   * to restart their client.\n   * @param {Function} callback Callback handling keys\n   * @returns {Promise<Function>}\n   */\n  captureShortcut(callback) {\n    const subid = subKey(RPCEvents.CAPTURE_SHORTCUT_CHANGE);\n    const stop = () => {\n      this._subscriptions.delete(subid);\n      return this.request(RPCCommands.CAPTURE_SHORTCUT, { action: 'STOP' });\n    };\n    this._subscriptions.set(subid, ({ shortcut }) => {\n      callback(shortcut, stop);\n    });\n    return this.request(RPCCommands.CAPTURE_SHORTCUT, { action: 'START' })\n      .then(() => stop);\n  }\n\n  /**\n   * Sets the presence for the logged in user.\n   * @param {object} args The rich presence to pass.\n   * @param {number} [pid] The application's process ID. Defaults to the executing process' PID.\n   * @returns {Promise}\n   */\n  setActivity(args = {}, pid = getPid()) {\n    let timestamps;\n    let assets;\n    let party;\n    let secrets;\n    if (args.startTimestamp || args.endTimestamp) {\n      timestamps = {\n        start: args.startTimestamp,\n        end: args.endTimestamp,\n      };\n      if (timestamps.start instanceof Date) {\n        timestamps.start = Math.round(timestamps.start.getTime());\n      }\n      if (timestamps.end instanceof Date) {\n        timestamps.end = Math.round(timestamps.end.getTime());\n      }\n      if (timestamps.start > 2147483647000) {\n        throw new RangeError('timestamps.start must fit into a unix timestamp');\n      }\n      if (timestamps.end > 2147483647000) {\n        throw new RangeError('timestamps.end must fit into a unix timestamp');\n      }\n    }\n    if (\n      args.largeImageKey || args.largeImageText\n      || args.smallImageKey || args.smallImageText\n    ) {\n      assets = {\n        large_image: args.largeImageKey,\n        large_text: args.largeImageText,\n        small_image: args.smallImageKey,\n        small_text: args.smallImageText,\n      };\n    }\n    if (args.partySize || args.partyId || args.partyMax) {\n      party = { id: args.partyId };\n      if (args.partySize || args.partyMax) {\n        party.size = [args.partySize, args.partyMax];\n      }\n    }\n    if (args.matchSecret || args.joinSecret || args.spectateSecret) {\n      secrets = {\n        match: args.matchSecret,\n        join: args.joinSecret,\n        spectate: args.spectateSecret,\n      };\n    }\n\n    return this.request(RPCCommands.SET_ACTIVITY, {\n      pid,\n      activity: {\n        state: args.state,\n        details: args.details,\n        timestamps,\n        assets,\n        party,\n        secrets,\n        buttons: args.buttons,\n        instance: !!args.instance,\n      },\n    });\n  }\n\n  /**\n   * Clears the currently set presence, if any. This will hide the \"Playing X\" message\n   * displayed below the user's name.\n   * @param {number} [pid] The application's process ID. Defaults to the executing process' PID.\n   * @returns {Promise}\n   */\n  clearActivity(pid = getPid()) {\n    return this.request(RPCCommands.SET_ACTIVITY, {\n      pid,\n    });\n  }\n\n  /**\n   * Invite a user to join the game the RPC user is currently playing\n   * @param {User} user The user to invite\n   * @returns {Promise}\n   */\n  sendJoinInvite(user) {\n    return this.request(RPCCommands.SEND_ACTIVITY_JOIN_INVITE, {\n      user_id: user.id || user,\n    });\n  }\n\n  /**\n   * Request to join the game the user is playing\n   * @param {User} user The user whose game you want to request to join\n   * @returns {Promise}\n   */\n  sendJoinRequest(user) {\n    return this.request(RPCCommands.SEND_ACTIVITY_JOIN_REQUEST, {\n      user_id: user.id || user,\n    });\n  }\n\n  /**\n   * Reject a join request from a user\n   * @param {User} user The user whose request you wish to reject\n   * @returns {Promise}\n   */\n  closeJoinRequest(user) {\n    return this.request(RPCCommands.CLOSE_ACTIVITY_JOIN_REQUEST, {\n      user_id: user.id || user,\n    });\n  }\n\n  createLobby(type, capacity, metadata) {\n    return this.request(RPCCommands.CREATE_LOBBY, {\n      type,\n      capacity,\n      metadata,\n    });\n  }\n\n  updateLobby(lobby, { type, owner, capacity, metadata } = {}) {\n    return this.request(RPCCommands.UPDATE_LOBBY, {\n      id: lobby.id || lobby,\n      type,\n      owner_id: (owner && owner.id) || owner,\n      capacity,\n      metadata,\n    });\n  }\n\n  deleteLobby(lobby) {\n    return this.request(RPCCommands.DELETE_LOBBY, {\n      id: lobby.id || lobby,\n    });\n  }\n\n  connectToLobby(id, secret) {\n    return this.request(RPCCommands.CONNECT_TO_LOBBY, {\n      id,\n      secret,\n    });\n  }\n\n  sendToLobby(lobby, data) {\n    return this.request(RPCCommands.SEND_TO_LOBBY, {\n      id: lobby.id || lobby,\n      data,\n    });\n  }\n\n  disconnectFromLobby(lobby) {\n    return this.request(RPCCommands.DISCONNECT_FROM_LOBBY, {\n      id: lobby.id || lobby,\n    });\n  }\n\n  updateLobbyMember(lobby, user, metadata) {\n    return this.request(RPCCommands.UPDATE_LOBBY_MEMBER, {\n      lobby_id: lobby.id || lobby,\n      user_id: user.id || user,\n      metadata,\n    });\n  }\n\n  getRelationships() {\n    const types = Object.keys(RelationshipTypes);\n    return this.request(RPCCommands.GET_RELATIONSHIPS)\n      .then((o) => o.relationships.map((r) => ({\n        ...r,\n        type: types[r.type],\n      })));\n  }\n\n  /**\n   * Subscribe to an event\n   * @param {string} event Name of event e.g. `MESSAGE_CREATE`\n   * @param {Object} [args] Args for event e.g. `{ channel_id: '1234' }`\n   * @returns {Promise<Object>}\n   */\n  async subscribe(event, args) {\n    await this.request(RPCCommands.SUBSCRIBE, args, event);\n    return {\n      unsubscribe: () => this.request(RPCCommands.UNSUBSCRIBE, args, event),\n    };\n  }\n\n  /**\n   * Destroy the client\n   */\n  async destroy() {\n    await this.transport.close();\n  }\n}\n\nmodule.exports = RPCClient;\n","'use strict';\n\nfunction keyMirror(arr) {\n  const tmp = {};\n  for (const value of arr) {\n    tmp[value] = value;\n  }\n  return tmp;\n}\n\n\nexports.browser = typeof window !== 'undefined';\n\nexports.RPCCommands = keyMirror([\n  'DISPATCH',\n  'AUTHORIZE',\n  'AUTHENTICATE',\n  'GET_GUILD',\n  'GET_GUILDS',\n  'GET_CHANNEL',\n  'GET_CHANNELS',\n  'CREATE_CHANNEL_INVITE',\n  'GET_RELATIONSHIPS',\n  'GET_USER',\n  'SUBSCRIBE',\n  'UNSUBSCRIBE',\n  'SET_USER_VOICE_SETTINGS',\n  'SET_USER_VOICE_SETTINGS_2',\n  'SELECT_VOICE_CHANNEL',\n  'GET_SELECTED_VOICE_CHANNEL',\n  'SELECT_TEXT_CHANNEL',\n  'GET_VOICE_SETTINGS',\n  'SET_VOICE_SETTINGS_2',\n  'SET_VOICE_SETTINGS',\n  'CAPTURE_SHORTCUT',\n  'SET_ACTIVITY',\n  'SEND_ACTIVITY_JOIN_INVITE',\n  'CLOSE_ACTIVITY_JOIN_REQUEST',\n  'ACTIVITY_INVITE_USER',\n  'ACCEPT_ACTIVITY_INVITE',\n  'INVITE_BROWSER',\n  'DEEP_LINK',\n  'CONNECTIONS_CALLBACK',\n  'BRAINTREE_POPUP_BRIDGE_CALLBACK',\n  'GIFT_CODE_BROWSER',\n  'GUILD_TEMPLATE_BROWSER',\n  'OVERLAY',\n  'BROWSER_HANDOFF',\n  'SET_CERTIFIED_DEVICES',\n  'GET_IMAGE',\n  'CREATE_LOBBY',\n  'UPDATE_LOBBY',\n  'DELETE_LOBBY',\n  'UPDATE_LOBBY_MEMBER',\n  'CONNECT_TO_LOBBY',\n  'DISCONNECT_FROM_LOBBY',\n  'SEND_TO_LOBBY',\n  'SEARCH_LOBBIES',\n  'CONNECT_TO_LOBBY_VOICE',\n  'DISCONNECT_FROM_LOBBY_VOICE',\n  'SET_OVERLAY_LOCKED',\n  'OPEN_OVERLAY_ACTIVITY_INVITE',\n  'OPEN_OVERLAY_GUILD_INVITE',\n  'OPEN_OVERLAY_VOICE_SETTINGS',\n  'VALIDATE_APPLICATION',\n  'GET_ENTITLEMENT_TICKET',\n  'GET_APPLICATION_TICKET',\n  'START_PURCHASE',\n  'GET_SKUS',\n  'GET_ENTITLEMENTS',\n  'GET_NETWORKING_CONFIG',\n  'NETWORKING_SYSTEM_METRICS',\n  'NETWORKING_PEER_METRICS',\n  'NETWORKING_CREATE_TOKEN',\n  'SET_USER_ACHIEVEMENT',\n  'GET_USER_ACHIEVEMENTS',\n]);\n\nexports.RPCEvents = keyMirror([\n  'CURRENT_USER_UPDATE',\n  'GUILD_STATUS',\n  'GUILD_CREATE',\n  'CHANNEL_CREATE',\n  'RELATIONSHIP_UPDATE',\n  'VOICE_CHANNEL_SELECT',\n  'VOICE_STATE_CREATE',\n  'VOICE_STATE_DELETE',\n  'VOICE_STATE_UPDATE',\n  'VOICE_SETTINGS_UPDATE',\n  'VOICE_SETTINGS_UPDATE_2',\n  'VOICE_CONNECTION_STATUS',\n  'SPEAKING_START',\n  'SPEAKING_STOP',\n  'GAME_JOIN',\n  'GAME_SPECTATE',\n  'ACTIVITY_JOIN',\n  'ACTIVITY_JOIN_REQUEST',\n  'ACTIVITY_SPECTATE',\n  'ACTIVITY_INVITE',\n  'NOTIFICATION_CREATE',\n  'MESSAGE_CREATE',\n  'MESSAGE_UPDATE',\n  'MESSAGE_DELETE',\n  'LOBBY_DELETE',\n  'LOBBY_UPDATE',\n  'LOBBY_MEMBER_CONNECT',\n  'LOBBY_MEMBER_DISCONNECT',\n  'LOBBY_MEMBER_UPDATE',\n  'LOBBY_MESSAGE',\n  'CAPTURE_SHORTCUT_CHANGE',\n  'OVERLAY',\n  'OVERLAY_UPDATE',\n  'ENTITLEMENT_CREATE',\n  'ENTITLEMENT_DELETE',\n  'USER_ACHIEVEMENT_UPDATE',\n  'READY',\n  'ERROR',\n]);\n\nexports.RPCErrors = {\n  CAPTURE_SHORTCUT_ALREADY_LISTENING: 5004,\n  GET_GUILD_TIMED_OUT: 5002,\n  INVALID_ACTIVITY_JOIN_REQUEST: 4012,\n  INVALID_ACTIVITY_SECRET: 5005,\n  INVALID_CHANNEL: 4005,\n  INVALID_CLIENTID: 4007,\n  INVALID_COMMAND: 4002,\n  INVALID_ENTITLEMENT: 4015,\n  INVALID_EVENT: 4004,\n  INVALID_GIFT_CODE: 4016,\n  INVALID_GUILD: 4003,\n  INVALID_INVITE: 4011,\n  INVALID_LOBBY: 4013,\n  INVALID_LOBBY_SECRET: 4014,\n  INVALID_ORIGIN: 4008,\n  INVALID_PAYLOAD: 4000,\n  INVALID_PERMISSIONS: 4006,\n  INVALID_TOKEN: 4009,\n  INVALID_USER: 4010,\n  LOBBY_FULL: 5007,\n  NO_ELIGIBLE_ACTIVITY: 5006,\n  OAUTH2_ERROR: 5000,\n  PURCHASE_CANCELED: 5008,\n  PURCHASE_ERROR: 5009,\n  RATE_LIMITED: 5011,\n  SELECT_CHANNEL_TIMED_OUT: 5001,\n  SELECT_VOICE_FORCE_REQUIRED: 5003,\n  SERVICE_UNAVAILABLE: 1001,\n  TRANSACTION_ABORTED: 1002,\n  UNAUTHORIZED_FOR_ACHIEVEMENT: 5010,\n  UNKNOWN_ERROR: 1000,\n};\n\nexports.RPCCloseCodes = {\n  CLOSE_NORMAL: 1000,\n  CLOSE_UNSUPPORTED: 1003,\n  CLOSE_ABNORMAL: 1006,\n  INVALID_CLIENTID: 4000,\n  INVALID_ORIGIN: 4001,\n  RATELIMITED: 4002,\n  TOKEN_REVOKED: 4003,\n  INVALID_VERSION: 4004,\n  INVALID_ENCODING: 4005,\n};\n\nexports.LobbyTypes = {\n  PRIVATE: 1,\n  PUBLIC: 2,\n};\n\nexports.RelationshipTypes = {\n  NONE: 0,\n  FRIEND: 1,\n  BLOCKED: 2,\n  PENDING_INCOMING: 3,\n  PENDING_OUTGOING: 4,\n  IMPLICIT: 5,\n};\n","'use strict';\n\nconst util = require('./util');\n\nmodule.exports = {\n  Client: require('./client'),\n  register(id) {\n    return util.register(`discord-${id}`);\n  },\n};\n","'use strict';\n\nmodule.exports = {\n  ipc: require('./ipc'),\n  websocket: require('./websocket'),\n};\n","'use strict';\n\nconst net = require('net');\nconst EventEmitter = require('events');\nconst fetch = require('node-fetch');\nconst { uuid } = require('../util');\n\nconst OPCodes = {\n  HANDSHAKE: 0,\n  FRAME: 1,\n  CLOSE: 2,\n  PING: 3,\n  PONG: 4,\n};\n\nfunction getIPCPath(id) {\n  if (process.platform === 'win32') {\n    return `\\\\\\\\?\\\\pipe\\\\discord-ipc-${id}`;\n  }\n  const { env: { XDG_RUNTIME_DIR, TMPDIR, TMP, TEMP } } = process;\n  const prefix = XDG_RUNTIME_DIR || TMPDIR || TMP || TEMP || '/tmp';\n  return `${prefix.replace(/\\/$/, '')}/discord-ipc-${id}`;\n}\n\nfunction getIPC(id = 0) {\n  return new Promise((resolve, reject) => {\n    const path = getIPCPath(id);\n    const onerror = () => {\n      if (id < 10) {\n        resolve(getIPC(id + 1));\n      } else {\n        reject(new Error('Could not connect'));\n      }\n    };\n    const sock = net.createConnection(path, () => {\n      sock.removeListener('error', onerror);\n      resolve(sock);\n    });\n    sock.once('error', onerror);\n  });\n}\n\nasync function findEndpoint(tries = 0) {\n  if (tries > 30) {\n    throw new Error('Could not find endpoint');\n  }\n  const endpoint = `http://127.0.0.1:${6463 + (tries % 10)}`;\n  try {\n    const r = await fetch(endpoint);\n    if (r.status === 404) {\n      return endpoint;\n    }\n    return findEndpoint(tries + 1);\n  } catch (e) {\n    return findEndpoint(tries + 1);\n  }\n}\n\nfunction encode(op, data) {\n  data = JSON.stringify(data);\n  const len = Buffer.byteLength(data);\n  const packet = Buffer.alloc(8 + len);\n  packet.writeInt32LE(op, 0);\n  packet.writeInt32LE(len, 4);\n  packet.write(data, 8, len);\n  return packet;\n}\n\nconst working = {\n  full: '',\n  op: undefined,\n};\n\nfunction decode(socket, callback) {\n  const packet = socket.read();\n  if (!packet) {\n    return;\n  }\n\n  let { op } = working;\n  let raw;\n  if (working.full === '') {\n    op = working.op = packet.readInt32LE(0);\n    const len = packet.readInt32LE(4);\n    raw = packet.slice(8, len + 8);\n  } else {\n    raw = packet.toString();\n  }\n\n  try {\n    const data = JSON.parse(working.full + raw);\n    callback({ op, data }); // eslint-disable-line callback-return\n    working.full = '';\n    working.op = undefined;\n  } catch (err) {\n    working.full += raw;\n  }\n\n  decode(socket, callback);\n}\n\nclass IPCTransport extends EventEmitter {\n  constructor(client) {\n    super();\n    this.client = client;\n    this.socket = null;\n  }\n\n  async connect() {\n    const socket = this.socket = await getIPC();\n    socket.on('close', this.onClose.bind(this));\n    socket.on('error', this.onClose.bind(this));\n    this.emit('open');\n    socket.write(encode(OPCodes.HANDSHAKE, {\n      v: 1,\n      client_id: this.client.clientId,\n    }));\n    socket.pause();\n    socket.on('readable', () => {\n      decode(socket, ({ op, data }) => {\n        switch (op) {\n          case OPCodes.PING:\n            this.send(data, OPCodes.PONG);\n            break;\n          case OPCodes.FRAME:\n            if (!data) {\n              return;\n            }\n            if (data.cmd === 'AUTHORIZE' && data.evt !== 'ERROR') {\n              findEndpoint()\n                .then((endpoint) => {\n                  this.client.request.endpoint = endpoint;\n                })\n                .catch((e) => {\n                  this.client.emit('error', e);\n                });\n            }\n            this.emit('message', data);\n            break;\n          case OPCodes.CLOSE:\n            this.emit('close', data);\n            break;\n          default:\n            break;\n        }\n      });\n    });\n  }\n\n  onClose(e) {\n    this.emit('close', e);\n  }\n\n  send(data, op = OPCodes.FRAME) {\n    this.socket.write(encode(op, data));\n  }\n\n  async close() {\n    return new Promise((r) => {\n      this.once('close', r);\n      this.send({}, OPCodes.CLOSE);\n      this.socket.end();\n    });\n  }\n\n  ping() {\n    this.send(uuid(), OPCodes.PING);\n  }\n}\n\nmodule.exports = IPCTransport;\nmodule.exports.encode = encode;\nmodule.exports.decode = decode;\n","'use strict';\n\nconst EventEmitter = require('events');\nconst { browser } = require('../constants');\n\n// eslint-disable-next-line\nconst WebSocket = browser ? window.WebSocket : require('ws');\n\nconst pack = (d) => JSON.stringify(d);\nconst unpack = (s) => JSON.parse(s);\n\nclass WebSocketTransport extends EventEmitter {\n  constructor(client) {\n    super();\n    this.client = client;\n    this.ws = null;\n    this.tries = 0;\n  }\n\n  async connect() {\n    const port = 6463 + (this.tries % 10);\n    this.tries += 1;\n\n    this.ws = new WebSocket(\n      `ws://127.0.0.1:${port}/?v=1&client_id=${this.client.clientId}`,\n      browser ? undefined : { origin: this.client.options.origin },\n    );\n    this.ws.onopen = this.onOpen.bind(this);\n    this.ws.onclose = this.onClose.bind(this);\n    this.ws.onerror = this.onError.bind(this);\n    this.ws.onmessage = this.onMessage.bind(this);\n  }\n\n  onOpen() {\n    this.emit('open');\n  }\n\n  onClose(event) {\n    if (!event.wasClean) {\n      return;\n    }\n    this.emit('close', event);\n  }\n\n  onError(event) {\n    try {\n      this.ws.close();\n    } catch {} // eslint-disable-line no-empty\n\n    if (this.tries > 20) {\n      this.emit('error', event.error);\n    } else {\n      setTimeout(() => {\n        this.connect();\n      }, 250);\n    }\n  }\n\n  onMessage(event) {\n    this.emit('message', unpack(event.data));\n  }\n\n  send(data) {\n    this.ws.send(pack(data));\n  }\n\n  ping() {} // eslint-disable-line no-empty-function\n\n  close() {\n    return new Promise((r) => {\n      this.once('close', r);\n      this.ws.close();\n    });\n  }\n}\n\nmodule.exports = WebSocketTransport;\n","'use strict';\n\nlet register;\ntry {\n  const { app } = require('electron');\n  register = app.setAsDefaultProtocolClient.bind(app);\n} catch (err) {\n  try {\n    register = require('register-scheme');\n  } catch (e) {} // eslint-disable-line no-empty\n}\n\nif (typeof register !== 'function') {\n  register = () => false;\n}\n\nfunction pid() {\n  if (typeof process !== 'undefined') {\n    return process.pid;\n  }\n  return null;\n}\n\nconst uuid4122 = () => {\n  let uuid = '';\n  for (let i = 0; i < 32; i += 1) {\n    if (i === 8 || i === 12 || i === 16 || i === 20) {\n      uuid += '-';\n    }\n    let n;\n    if (i === 12) {\n      n = 4;\n    } else {\n      const random = Math.random() * 16 | 0;\n      if (i === 16) {\n        n = (random & 3) | 0;\n      } else {\n        n = random;\n      }\n    }\n    uuid += n.toString(16);\n  }\n  return uuid;\n};\n\nmodule.exports = {\n  pid,\n  register,\n  uuid: uuid4122,\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","\"use strict\";\n\n// ref: https://github.com/tc39/proposal-global\nvar getGlobal = function () {\n\t// the only reliable means to get the global object is\n\t// `Function('return this')()`\n\t// However, this causes CSP violations in Chrome apps.\n\tif (typeof self !== 'undefined') { return self; }\n\tif (typeof window !== 'undefined') { return window; }\n\tif (typeof global !== 'undefined') { return global; }\n\tthrow new Error('unable to locate global object');\n}\n\nvar globalObject = getGlobal();\n\nmodule.exports = exports = globalObject.fetch;\n\n// Needed for TypeScript and Webpack.\nif (globalObject.fetch) {\n\texports.default = globalObject.fetch.bind(globalObject);\n}\n\nexports.Headers = globalObject.Headers;\nexports.Request = globalObject.Request;\nexports.Response = globalObject.Response;\n","\nexports.every = function(str) {\n  return new Every(str);\n};\n\n/*\n  Time map\n*/\n\nvar time = {\n  millisecond: 1,\n  second: 1000,\n  minute: 60000,\n  hour: 3600000,\n  day: 86400000\n};\n\nfor (var key in time) {\n  if (key === 'millisecond') {\n    time.ms = time[key];\n  } else {\n    time[key.charAt(0)] = time[key];\n  }\n  time[key + 's'] = time[key];\n}\n\n\n/*\n  Every constructor\n*/\n\nfunction Every(str) {\n  this.count = 0;\n  var m = parse(str);\n  if (m) {\n    this.time = Number(m[0]) * time[m[1]];\n    this.type = m[1];\n  }\n}\n\nEvery.prototype.do = function(cb) {\n  if (this.time) {\n    this.interval = setInterval(callback, this.time);\n  }\n\n  var that = this;\n  function callback() {\n    that.count++;\n    cb.call(that);\n  }\n  return this;\n};\n\nEvery.prototype.stop = function() {\n  if (this.interval) {\n    clearInterval(this.interval);\n    delete this.interval;\n  }\n  return this;\n};\n\n\n/*\n  Convert string to milliseconds\n\n    ms, millisecond(s)?\n    s, second(s)?\n    m, minute(s)?\n    h, hour(s)?\n    d, day(s)?\n*/\nvar reg = /^\\s*(\\d+(?:\\.\\d+)?)\\s*([a-z]+)\\s*$/;\n\nfunction parse(str) {\n  var m = str.match(reg);\n  if (m && time[m[2]]) {\n    return m.slice(1);\n  }\n  return null;\n}\n","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import DiscordRPC from 'discord-rpc';\r\n\r\nconst clientId = '1207793663963562046';\r\n\r\nconst rpc = new DiscordRPC.Client({ transport: 'ipc' });\r\n\r\nDiscordRPC.register(clientId);\r\n\r\nrpc.on('ready', () => {\r\n  console.log('Ready!');\r\n  rpc.setActivity({\r\n    details: 'Listening to',\r\n    state: 'Level 1',\r\n    startTimestamp: new Date(),\r\n    largeImageKey: 'game-logo',\r\n    largeImageText: 'Game Name',\r\n    smallImageKey: 'character-name',\r\n    smallImageText: 'Character Name',\r\n    buttons: [\r\n      { label: 'Visit Website', url: 'https://example.com' },\r\n      { label: 'Download Now', url: 'https://example.com/download' },\r\n    ],\r\n  });\r\n});\r\n\r\nrpc.login({ clientId: clientId }).catch(console.error);"],"names":[],"sourceRoot":""}